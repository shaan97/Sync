.TH "nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer" 3 "Tue Jul 18 2017" "Version 1.0.0" "Sync" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer \- JSON Pointer\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <json\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBjson_pointer\fP (const std::string &s='')"
.br
.RI "create JSON pointer "
.ti -1c
.RI "std::string \fBto_string\fP () const noexcept"
.br
.RI "return a string representation of the JSON pointer "
.ti -1c
.RI "\fBoperator std::string\fP () const"
.br
.RI "return a string representation of the JSON pointer "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "std::string \fBpop_back\fP ()"
.br
.RI "remove and return last reference pointer "
.ti -1c
.RI "bool \fBis_root\fP () const"
.br
.RI "return whether pointer points to the root document "
.ti -1c
.RI "\fBjson_pointer\fP \fBtop\fP () const"
.br
.ti -1c
.RI "\fBreference\fP \fBget_and_create\fP (\fBreference\fP j) const"
.br
.RI "create and return a reference to the pointed to value "
.ti -1c
.RI "\fBreference\fP \fBget_unchecked\fP (\fBpointer\fP ptr) const"
.br
.RI "return a reference to the pointed to value "
.ti -1c
.RI "\fBreference\fP \fBget_checked\fP (\fBpointer\fP ptr) const"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBget_unchecked\fP (\fBconst_pointer\fP ptr) const"
.br
.RI "return a const reference to the pointed to value "
.ti -1c
.RI "\fBconst_reference\fP \fBget_checked\fP (\fBconst_pointer\fP ptr) const"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static std::vector< std::string > \fBsplit\fP (const std::string &reference_string)"
.br
.RI "split the string input to reference tokens "
.ti -1c
.RI "static void \fBreplace_substring\fP (std::string &s, const std::string &f, const std::string &t)"
.br
.RI "replace all occurrences of a substring by another string "
.ti -1c
.RI "static std::string \fBescape\fP (std::string s)"
.br
.RI "escape tilde and slash "
.ti -1c
.RI "static void \fBunescape\fP (std::string &s)"
.br
.RI "unescape tilde and slash "
.ti -1c
.RI "static void \fBflatten\fP (const std::string &reference_string, const \fBbasic_json\fP &\fBvalue\fP, \fBbasic_json\fP &result)"
.br
.ti -1c
.RI "static \fBbasic_json\fP \fBunflatten\fP (const \fBbasic_json\fP &\fBvalue\fP)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::vector< std::string > \fBreference_tokens\fP {}"
.br
.RI "the reference tokens "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBbasic_json\fP"
.br
.RI "allow \fBbasic_json\fP to access private members "
.ti -1c
.RI "bool \fBoperator==\fP (\fBjson_pointer\fP const &lhs, \fBjson_pointer\fP const &rhs) noexcept"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (\fBjson_pointer\fP const &lhs, \fBjson_pointer\fP const &rhs) noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer>
.br
class nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer"
JSON Pointer\&. 

A JSON pointer defines a string syntax for identifying a specific value within a JSON document\&. It can be used with functions \fCat\fP and \fCoperator[]\fP\&. Furthermore, JSON pointers are the base for JSON patches\&.
.PP
\fBSee also:\fP
.RS 4
\fCRFC 6901\fP
.RE
.PP
\fBSince:\fP
.RS 4
version 2\&.0\&.0 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::json_pointer (const std::string & s = \fC''\fP)\fC [inline]\fP, \fC [explicit]\fP"

.PP
create JSON pointer Create a JSON pointer according to the syntax described in \fCSection 3 of RFC6901\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIs\fP string representing the JSON pointer; if omitted, the empty string is assumed which references the whole JSON value
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIstd::domain_error\fP if reference token is nonempty and does not begin with a slash (\fC/\fP); example: \fC'JSON pointer must be empty or
begin with /'\fP 
.br
\fIstd::domain_error\fP if a tilde (\fC~\fP) is not followed by \fC0\fP (representing \fC~\fP) or \fC1\fP (representing \fC/\fP); example: \fC'escape error:
~ must be followed with 0 or 1'\fP
.RE
.PP
{The example shows the construction several valid JSON pointers as well as the exceptional behavior\&.,\fBjson_pointer\fP}
.PP
\fBSince:\fP
.RS 4
version 2\&.0\&.0 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> static std::string \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::escape (std::string s)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
escape tilde and slash 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> static void \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::flatten (const std::string & reference_string, const \fBbasic_json\fP & value, \fBbasic_json\fP & result)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIreference_string\fP the reference string to the current value 
.br
\fIvalue\fP the value to consider 
.br
\fIresult\fP the result object to insert values to
.RE
.PP
\fBNote:\fP
.RS 4
Empty objects or arrays are flattened to \fCnull\fP\&. 
.RE
.PP

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBreference\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::get_and_create (\fBreference\fP j) const\fC [inline]\fP, \fC [private]\fP"

.PP
create and return a reference to the pointed to value Linear in the number of reference tokens\&. 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBreference\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::get_checked (\fBpointer\fP ptr) const\fC [inline]\fP, \fC [private]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBconst_reference\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::get_checked (\fBconst_pointer\fP ptr) const\fC [inline]\fP, \fC [private]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBreference\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::get_unchecked (\fBpointer\fP ptr) const\fC [inline]\fP, \fC [private]\fP"

.PP
return a reference to the pointed to value 
.PP
\fBNote:\fP
.RS 4
This version does not throw if a value is not present, but tries to create nested values instead\&. For instance, calling this function with pointer \fC'/this/that'\fP on a null value is equivalent to calling \fCoperator[]('this')\&.operator[]('that')\fP on that value, effectively changing the null value to an object\&.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP a JSON value
.RE
.PP
\fBReturns:\fP
.RS 4
reference to the JSON value pointed to by the JSON pointer
.RE
.PP
Linear in the length of the JSON pointer\&.
.PP
\fBExceptions:\fP
.RS 4
\fIstd::out_of_range\fP if the JSON pointer can not be resolved 
.br
\fIstd::domain_error\fP if an array index begins with '0' 
.br
\fIstd::invalid_argument\fP if an array index was not a number 
.RE
.PP

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBconst_reference\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::get_unchecked (\fBconst_pointer\fP ptr) const\fC [inline]\fP, \fC [private]\fP"

.PP
return a const reference to the pointed to value 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP a JSON value
.RE
.PP
\fBReturns:\fP
.RS 4
const reference to the JSON value pointed to by the JSON pointer 
.RE
.PP

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> bool \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::is_root () const\fC [inline]\fP, \fC [private]\fP"

.PP
return whether pointer points to the root document 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::operator std::string () const\fC [inline]\fP"

.PP
return a string representation of the JSON pointer 
.PP
\fBInvariant:\fP
.RS 4
For each JSON pointer \fCptr\fP, it holds: 
.PP
.nf
ptr == json_pointer(ptr\&.to_string());

.fi
.PP
.RE
.PP
\fBReturns:\fP
.RS 4
a string representation of the JSON pointer
.RE
.PP
{The example shows the result of \fCto_string\fP\&., json_pointer__to_string}
.PP
\fBSince:\fP
.RS 4
version 2\&.0\&.0 
.RE
.PP

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> std::string \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::pop_back ()\fC [inline]\fP, \fC [private]\fP"

.PP
remove and return last reference pointer 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> static void \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::replace_substring (std::string & s, const std::string & f, const std::string & t)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
replace all occurrences of a substring by another string 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP the string to manipulate; changed so that all occurrences of \fIf\fP are replaced with \fIt\fP 
.br
\fIf\fP the substring to replace with \fIt\fP 
.br
\fIt\fP the string to replace \fIf\fP 
.RE
.PP
\fBPrecondition:\fP
.RS 4
The search string \fIf\fP must not be empty\&.
.RE
.PP
\fBSince:\fP
.RS 4
version 2\&.0\&.0 
.RE
.PP

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> static std::vector<std::string> \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::split (const std::string & reference_string)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
split the string input to reference tokens 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> std::string \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::to_string () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
return a string representation of the JSON pointer 
.PP
\fBInvariant:\fP
.RS 4
For each JSON pointer \fCptr\fP, it holds: 
.PP
.nf
ptr == json_pointer(ptr\&.to_string());

.fi
.PP
.RE
.PP
\fBReturns:\fP
.RS 4
a string representation of the JSON pointer
.RE
.PP
{The example shows the result of \fCto_string\fP\&., json_pointer__to_string}
.PP
\fBSince:\fP
.RS 4
version 2\&.0\&.0 
.RE
.PP

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> \fBjson_pointer\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::top () const\fC [inline]\fP, \fC [private]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> static void \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::unescape (std::string & s)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
unescape tilde and slash 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> static \fBbasic_json\fP \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::unflatten (const \fBbasic_json\fP & value)\fC [inline]\fP, \fC [static]\fP, \fC [private]\fP"

.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP flattened JSON
.RE
.PP
\fBReturns:\fP
.RS 4
unflattened JSON 
.RE
.PP

.SH "Friends And Related Function Documentation"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> friend class \fBbasic_json\fP\fC [friend]\fP"

.PP
allow \fBbasic_json\fP to access private members 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> bool operator!= (\fBjson_pointer\fP const & lhs, \fBjson_pointer\fP const & rhs)\fC [friend]\fP"

.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> bool operator== (\fBjson_pointer\fP const & lhs, \fBjson_pointer\fP const & rhs)\fC [friend]\fP"

.SH "Member Data Documentation"
.PP 
.SS "template<template< typename U, typename V, typename\&.\&.\&. Args > class ObjectType = std::map, template< typename U, typename\&.\&.\&. Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer> std::vector<std::string> \fBnlohmann::basic_json\fP< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer >::json_pointer::reference_tokens {}\fC [private]\fP"

.PP
the reference tokens 

.SH "Author"
.PP 
Generated automatically by Doxygen for Sync from the source code\&.
