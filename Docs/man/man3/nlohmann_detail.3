.TH "nlohmann::detail" 3 "Tue Jul 18 2017" "Version 1.0.0" "Sync" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nlohmann::detail \- unnamed namespace with internal helper functions  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBconjunction\fP"
.br
.ti -1c
.RI "struct \fBconjunction< B1 >\fP"
.br
.ti -1c
.RI "struct \fBconjunction< B1, Bn\&.\&.\&. >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::array >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::boolean >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::number_float >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::number_integer >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::number_unsigned >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::object >\fP"
.br
.ti -1c
.RI "struct \fBexternal_constructor< value_t::string >\fP"
.br
.ti -1c
.RI "struct \fBfrom_json_fn\fP"
.br
.ti -1c
.RI "struct \fBhas_from_json\fP"
.br
.ti -1c
.RI "struct \fBhas_non_default_from_json\fP"
.br
.ti -1c
.RI "struct \fBhas_to_json\fP"
.br
.ti -1c
.RI "struct \fBis_basic_json_nested_type\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_array_type\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_integer_type\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_integer_type_impl\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_integer_type_impl< true, RealIntegerType, CompatibleNumberIntegerType >\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_object_type\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_object_type_impl\fP"
.br
.ti -1c
.RI "struct \fBis_compatible_object_type_impl< true, RealType, CompatibleObjectType >\fP"
.br
.ti -1c
.RI "struct \fBnegation\fP"
.br
.ti -1c
.RI "struct \fBpriority_tag\fP"
.br
.ti -1c
.RI "struct \fBpriority_tag< 0 >\fP"
.br
.ti -1c
.RI "struct \fBstatic_const\fP"
.br
.ti -1c
.RI "struct \fBto_json_fn\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<bool B, typename T  = void> using \fBenable_if_t\fP = typename std::enable_if< B, T >::type"
.br
.ti -1c
.RI "template<typename T > using \fBuncvref_t\fP = typename std::remove_cv< typename std::remove_reference< T >::type >::type"
.br
.ti -1c
.RI "template<typename T > using \fBis_unscoped_enum\fP = std::integral_constant< bool, std::is_convertible< T, int >::value and std::is_enum< T >::value >"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBvalue_t\fP : uint8_t { \fBvalue_t::null\fP, \fBvalue_t::object\fP, \fBvalue_t::array\fP, \fBvalue_t::string\fP, \fBvalue_t::boolean\fP, \fBvalue_t::number_integer\fP, \fBvalue_t::number_unsigned\fP, \fBvalue_t::number_float\fP, \fBvalue_t::discarded\fP }
.RI "the JSON type enumeration ""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBoperator<\fP (const \fBvalue_t\fP lhs, const \fBvalue_t\fP rhs) noexcept"
.br
.RI "comparison operator for JSON types "
.ti -1c
.RI "\fBNLOHMANN_JSON_HAS_HELPER\fP (mapped_type)"
.br
.ti -1c
.RI "\fBNLOHMANN_JSON_HAS_HELPER\fP (key_type)"
.br
.ti -1c
.RI "\fBNLOHMANN_JSON_HAS_HELPER\fP (value_type)"
.br
.ti -1c
.RI "\fBNLOHMANN_JSON_HAS_HELPER\fP (iterator)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename T , enable_if_t< std::is_same< T, typename BasicJsonType::boolean_t >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, T b) noexcept"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleString , enable_if_t< std::is_constructible< typename BasicJsonType::string_t, CompatibleString >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, const CompatibleString &s)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename FloatType , enable_if_t< std::is_floating_point< FloatType >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, FloatType val) noexcept"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleNumberUnsignedType , enable_if_t< is_compatible_integer_type< typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, CompatibleNumberUnsignedType val) noexcept"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleNumberIntegerType , enable_if_t< is_compatible_integer_type< typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, CompatibleNumberIntegerType val) noexcept"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename UnscopedEnumType , enable_if_t< is_unscoped_enum< UnscopedEnumType >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, UnscopedEnumType e) noexcept"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleArrayType , enable_if_t< is_compatible_array_type< BasicJsonType, CompatibleArrayType >::value or std::is_same< typename BasicJsonType::array_t, CompatibleArrayType >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, const CompatibleArrayType &arr)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleObjectType , enable_if_t< is_compatible_object_type< BasicJsonType, CompatibleObjectType >::value, int >  = 0> void \fBto_json\fP (BasicJsonType &j, const CompatibleObjectType &arr)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename ArithmeticType , enable_if_t< std::is_arithmetic< ArithmeticType >::value and not std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void \fBget_arithmetic_value\fP (const BasicJsonType &j, ArithmeticType &val)"
.br
.ti -1c
.RI "template<typename BasicJsonType > void \fBfrom_json\fP (const BasicJsonType &j, typename BasicJsonType::boolean_t &b)"
.br
.ti -1c
.RI "template<typename BasicJsonType > void \fBfrom_json\fP (const BasicJsonType &j, typename BasicJsonType::string_t &s)"
.br
.ti -1c
.RI "template<typename BasicJsonType > void \fBfrom_json\fP (const BasicJsonType &j, typename BasicJsonType::number_float_t &val)"
.br
.ti -1c
.RI "template<typename BasicJsonType > void \fBfrom_json\fP (const BasicJsonType &j, typename BasicJsonType::number_unsigned_t &val)"
.br
.ti -1c
.RI "template<typename BasicJsonType > void \fBfrom_json\fP (const BasicJsonType &j, typename BasicJsonType::number_integer_t &val)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename UnscopedEnumType , enable_if_t< is_unscoped_enum< UnscopedEnumType >::value, int >  = 0> void \fBfrom_json\fP (const BasicJsonType &j, UnscopedEnumType &e)"
.br
.ti -1c
.RI "template<typename BasicJsonType > void \fBfrom_json\fP (const BasicJsonType &j, typename BasicJsonType::array_t &arr)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename T , typename Allocator > void \fBfrom_json\fP (const BasicJsonType &j, std::forward_list< T, Allocator > &l)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleArrayType > void \fBfrom_json_array_impl\fP (const BasicJsonType &j, CompatibleArrayType &arr, \fBpriority_tag\fP< 0 >)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleArrayType > auto \fBfrom_json_array_impl\fP (const BasicJsonType &j, CompatibleArrayType &arr, \fBpriority_tag\fP< 1 >) \-> decltype(arr\&.reserve(std::declval< typename CompatibleArrayType::size_type >()), void())"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleArrayType , enable_if_t< is_compatible_array_type< BasicJsonType, CompatibleArrayType >::value and not std::is_same< typename BasicJsonType::array_t, CompatibleArrayType >::value, int >  = 0> void \fBfrom_json\fP (const BasicJsonType &j, CompatibleArrayType &arr)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename CompatibleObjectType , enable_if_t< is_compatible_object_type< BasicJsonType, CompatibleObjectType >::value, int >  = 0> void \fBfrom_json\fP (const BasicJsonType &j, CompatibleObjectType &obj)"
.br
.ti -1c
.RI "template<typename BasicJsonType , typename ArithmeticType , enable_if_t< std::is_arithmetic< ArithmeticType >::value and not std::is_same< ArithmeticType, typename BasicJsonType::number_unsigned_t >::value and not std::is_same< ArithmeticType, typename BasicJsonType::number_integer_t >::value and not std::is_same< ArithmeticType, typename BasicJsonType::number_float_t >::value and not std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void \fBfrom_json\fP (const BasicJsonType &j, ArithmeticType &val)"
.br
.in -1c
.SH "Detailed Description"
.PP 
unnamed namespace with internal helper functions 

This namespace collects some functions that could not be defined inside the \fBbasic_json\fP class\&.
.PP
\fBSince:\fP
.RS 4
version 2\&.1\&.0 
.RE
.PP

.SH "Typedef Documentation"
.PP 
.SS "template<bool B, typename T  = void> using \fBnlohmann::detail::enable_if_t\fP = typedef typename std::enable_if<B, T>::type"

.SS "template<typename T > using \fBnlohmann::detail::is_unscoped_enum\fP = typedef std::integral_constant<bool, std::is_convertible<T, int>::value and std::is_enum<T>::value>"

.SS "template<typename T > using \fBnlohmann::detail::uncvref_t\fP = typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBnlohmann::detail::value_t\fP : uint8_t\fC [strong]\fP"

.PP
the JSON type enumeration This enumeration collects the different JSON types\&. It is internally used to distinguish the stored values, and the functions \fBbasic_json::is_null()\fP, \fBbasic_json::is_object()\fP, \fBbasic_json::is_array()\fP, \fBbasic_json::is_string()\fP, \fBbasic_json::is_boolean()\fP, \fBbasic_json::is_number()\fP (with \fBbasic_json::is_number_integer()\fP, \fBbasic_json::is_number_unsigned()\fP, and \fBbasic_json::is_number_float()\fP), \fBbasic_json::is_discarded()\fP, \fBbasic_json::is_primitive()\fP, and \fBbasic_json::is_structured()\fP rely on it\&.
.PP
\fBNote:\fP
.RS 4
There are three enumeration entries (number_integer, number_unsigned, and number_float), because the library distinguishes these three types for numbers: \fBbasic_json::number_unsigned_t\fP is used for unsigned integers, \fBbasic_json::number_integer_t\fP is used for signed integers, and \fBbasic_json::number_float_t\fP is used for floating-point numbers or to approximate integers which do not fit in the limits of their respective type\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBbasic_json::basic_json(const value_t value_type)\fP -- create a JSON value with the default value for a given type
.RE
.PP
\fBSince:\fP
.RS 4
version 1\&.0\&.0 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInull \fP\fP
null value 
.TP
\fB\fIobject \fP\fP
object (unordered set of name/value pairs) 
.TP
\fB\fIarray \fP\fP
array (ordered collection of values) 
.TP
\fB\fIstring \fP\fP
string value 
.TP
\fB\fIboolean \fP\fP
boolean value 
.TP
\fB\fInumber_integer \fP\fP
number value (signed integer) 
.TP
\fB\fInumber_unsigned \fP\fP
number value (unsigned integer) 
.TP
\fB\fInumber_float \fP\fP
number value (floating-point) 
.TP
\fB\fIdiscarded \fP\fP
discarded by the the parser callback function 
.SH "Function Documentation"
.PP 
.SS "template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType & j, typename BasicJsonType::boolean_t & b)"

.SS "template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType & j, typename BasicJsonType::string_t & s)"

.SS "template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType & j, typename BasicJsonType::number_float_t & val)"

.SS "template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType & j, typename BasicJsonType::number_unsigned_t & val)"

.SS "template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType & j, typename BasicJsonType::number_integer_t & val)"

.SS "template<typename BasicJsonType , typename UnscopedEnumType , enable_if_t< is_unscoped_enum< UnscopedEnumType >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType & j, UnscopedEnumType & e)"

.SS "template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType & j, typename BasicJsonType::array_t & arr)"

.SS "template<typename BasicJsonType , typename T , typename Allocator > void nlohmann::detail::from_json (const BasicJsonType & j, std::forward_list< T, Allocator > & l)"

.SS "template<typename BasicJsonType , typename CompatibleArrayType , enable_if_t< is_compatible_array_type< BasicJsonType, CompatibleArrayType >::value and not std::is_same< typename BasicJsonType::array_t, CompatibleArrayType >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType & j, CompatibleArrayType & arr)"

.SS "template<typename BasicJsonType , typename CompatibleObjectType , enable_if_t< is_compatible_object_type< BasicJsonType, CompatibleObjectType >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType & j, CompatibleObjectType & obj)"

.SS "template<typename BasicJsonType , typename ArithmeticType , enable_if_t< std::is_arithmetic< ArithmeticType >::value and not std::is_same< ArithmeticType, typename BasicJsonType::number_unsigned_t >::value and not std::is_same< ArithmeticType, typename BasicJsonType::number_integer_t >::value and not std::is_same< ArithmeticType, typename BasicJsonType::number_float_t >::value and not std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType & j, ArithmeticType & val)"

.SS "template<typename BasicJsonType , typename CompatibleArrayType > void nlohmann::detail::from_json_array_impl (const BasicJsonType & j, CompatibleArrayType & arr, \fBpriority_tag\fP< 0 >)"

.SS "template<typename BasicJsonType , typename CompatibleArrayType > auto nlohmann::detail::from_json_array_impl (const BasicJsonType & j, CompatibleArrayType & arr, \fBpriority_tag\fP< 1 >) \-> decltype(
    arr\&.reserve(std::declval<typename CompatibleArrayType::size_type>()),
    void())
"

.SS "template<typename BasicJsonType , typename ArithmeticType , enable_if_t< std::is_arithmetic< ArithmeticType >::value and not std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void nlohmann::detail::get_arithmetic_value (const BasicJsonType & j, ArithmeticType & val)"

.SS "nlohmann::detail::NLOHMANN_JSON_HAS_HELPER (mapped_type)"

.SS "nlohmann::detail::NLOHMANN_JSON_HAS_HELPER (key_type)"

.SS "nlohmann::detail::NLOHMANN_JSON_HAS_HELPER (value_type)"

.SS "nlohmann::detail::NLOHMANN_JSON_HAS_HELPER (iterator)"

.SS "bool nlohmann::detail::operator< (const \fBvalue_t\fP lhs, const \fBvalue_t\fP rhs)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
comparison operator for JSON types Returns an ordering that is similar to Python:
.IP "\(bu" 2
order: null < boolean < number < object < array < string
.IP "\(bu" 2
furthermore, each type is not smaller than itself
.PP
.PP
\fBSince:\fP
.RS 4
version 1\&.0\&.0 
.RE
.PP

.SS "template<typename BasicJsonType , typename T , enable_if_t< std::is_same< T, typename BasicJsonType::boolean_t >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, T b)\fC [noexcept]\fP"

.SS "template<typename BasicJsonType , typename CompatibleString , enable_if_t< std::is_constructible< typename BasicJsonType::string_t, CompatibleString >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, const CompatibleString & s)"

.SS "template<typename BasicJsonType , typename FloatType , enable_if_t< std::is_floating_point< FloatType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, FloatType val)\fC [noexcept]\fP"

.SS "template<typename BasicJsonType , typename CompatibleNumberUnsignedType , enable_if_t< is_compatible_integer_type< typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, CompatibleNumberUnsignedType val)\fC [noexcept]\fP"

.SS "template<typename BasicJsonType , typename CompatibleNumberIntegerType , enable_if_t< is_compatible_integer_type< typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, CompatibleNumberIntegerType val)\fC [noexcept]\fP"

.SS "template<typename BasicJsonType , typename UnscopedEnumType , enable_if_t< is_unscoped_enum< UnscopedEnumType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, UnscopedEnumType e)\fC [noexcept]\fP"

.SS "template<typename BasicJsonType , typename CompatibleArrayType , enable_if_t< is_compatible_array_type< BasicJsonType, CompatibleArrayType >::value or std::is_same< typename BasicJsonType::array_t, CompatibleArrayType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, const CompatibleArrayType & arr)"

.SS "template<typename BasicJsonType , typename CompatibleObjectType , enable_if_t< is_compatible_object_type< BasicJsonType, CompatibleObjectType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType & j, const CompatibleObjectType & arr)"

.SH "Author"
.PP 
Generated automatically by Doxygen for Sync from the source code\&.
