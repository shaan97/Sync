.TH "shaan97::sync::Group" 3 "Tue Jul 18 2017" "Version 1.0.0" "Sync" \" -*- nroff -*-
.ad l
.nh
.SH NAME
shaan97::sync::Group
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Group\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGroup\fP (const \fBGROUP_ID\fP &\fBgid\fP, \fBMember\fP &&member)"
.br
.ti -1c
.RI "\fBGroup\fP (const \fBGroup\fP &g)=delete"
.br
.RI "This would incur too much overhead, so we explicitly delete it\&. "
.ti -1c
.RI "\fBGroup\fP (\fBGroup\fP &&g)"
.br
.RI "Move constructors are more affordable, so we leverage this when needed\&. "
.ti -1c
.RI "virtual \fB~Group\fP ()"
.br
.RI "Declared in case future releases feature inheritance\&. "
.ti -1c
.RI "bool \fBaddMember\fP (\fBMember\fP &&member)"
.br
.ti -1c
.RI "bool \fBaddMember\fP (\fBMember\fP &&member, \fBError\fP &e)"
.br
.ti -1c
.RI "bool \fBdeleteMember\fP (const \fBMemberName\fP &member)"
.br
.ti -1c
.RI "bool \fBdeleteMember\fP (const \fBMemberName\fP &member, \fBError\fP &e)"
.br
.ti -1c
.RI "bool \fBpromoteMember\fP (const \fBMemberName\fP &member, \fBError\fP &e)"
.br
.ti -1c
.RI "std::size_t \fBnumMembers\fP () const"
.br
.RI "Get number of members\&. "
.ti -1c
.RI "const \fBMember\fP & \fBgetOwner\fP () const"
.br
.RI "Get owner of the \fBGroup\fP\&. "
.ti -1c
.RI "\fBGroup\fP & \fBoperator=\fP (const \fBGroup\fP &g)=delete"
.br
.RI "This would incur too much overhead, so we explicitly delete it\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBrun\fP ()"
.br
.ti -1c
.RI "void \fBresolveOwner\fP ()"
.br
.RI "Redetermine who the owner is\&. If the owner has left, then a new owner should be chosen\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBGROUP_ID\fP \fBgid\fP"
.br
.RI "\fBGroup\fP ID for this \fC\fBGroup\fP\fP instance\&. "
.ti -1c
.RI "\fBMemberName\fP \fBowner\fP"
.br
.RI "Name of the current owner\&. "
.ti -1c
.RI "std::unordered_map< \fBMemberName\fP, \fBMember\fP > \fBmembers\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This represents a group of clients who want to synchronize music amongst themselves\&. In some sense, this is an encapsulation of a collection of \fC\fBMember\fP\fPs
.PP
\fBSee also:\fP
.RS 4
\fBshaan97::sync::Member\fP
.RE
.PP
\fBNote:\fP
.RS 4
A \fC\fBGroup\fP\fP must always have at least one member\&. If there is no member, it is a wasted resource, and should thus be handled responsibly\&. 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "Group::Group (const \fBGROUP_ID\fP & gid, \fBMember\fP && member)"
Constructor to create a \fBGroup\fP 
.PP
\fBParameters:\fP
.RS 4
\fIgid\fP The name of the \fBGroup\fP created 
.br
\fImember\fP The first member (whose resources will be moved to here) 
.RE
.PP
\fBNote:\fP
.RS 4
The first member is made the owner of the group, since the assumption is that this member requested to make the group 
.RE
.PP

.SS "shaan97::sync::Group::Group (const \fBGroup\fP & g)\fC [delete]\fP"

.PP
This would incur too much overhead, so we explicitly delete it\&. 
.SS "Group::Group (\fBGroup\fP && g)"

.PP
Move constructors are more affordable, so we leverage this when needed\&. 
.SS "virtual shaan97::sync::Group::~Group ()\fC [virtual]\fP"

.PP
Declared in case future releases feature inheritance\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool Group::addMember (\fBMember\fP && member)"
Add a member to this group
.PP
\fBParameters:\fP
.RS 4
\fImember\fP The \fBMember\fP to be added 
.RE
.PP

.SS "bool Group::addMember (\fBMember\fP && member, \fBError\fP & e)"

.PP
Add a member to this group
.PP
\fBParameters:\fP
.RS 4
\fImember\fP The \fBMember\fP to be added 
.br
\fIe\fP Gives errors, if any occurred 
.RE
.PP

.SS "bool Group::deleteMember (const \fBMemberName\fP & member)"
Remove a member from this group\&. 
.PP
\fBParameters:\fP
.RS 4
\fImember\fP The name of the member to be removed 
.RE
.PP

.SS "bool Group::deleteMember (const \fBMemberName\fP & member, \fBError\fP & e)"

.PP
Remove a member from this group\&. 
.PP
\fBParameters:\fP
.RS 4
\fImember\fP The name of the member to be removed
.br
\fIe\fP Gives errors, if any occurred 
.RE
.PP

.SS "const \fBMember\fP & Group::getOwner () const"

.PP
Get owner of the \fBGroup\fP\&. 
.SS "std::size_t Group::numMembers () const"

.PP
Get number of members\&. 
.SS "\fBGroup\fP& shaan97::sync::Group::operator= (const \fBGroup\fP & g)\fC [delete]\fP"

.PP
This would incur too much overhead, so we explicitly delete it\&. 
.SS "bool Group::promoteMember (const \fBMemberName\fP & member, \fBError\fP & e)"
Promotes a member to owner of the group\&.
.PP
\fBParameters:\fP
.RS 4
\fImember\fP Name of the member who will be promoted 
.br
\fIe\fP Gives errors, if any occurred
.RE
.PP
\fBPrecondition:\fP
.RS 4
It is expected that the caller has already verified that this operation can happen (e\&.g\&. the current owner promoted him/her, or we are resolving the owner) 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBresolveOwner()\fP 
.RE
.PP

.SS "void Group::resolveOwner ()\fC [inline]\fP, \fC [private]\fP"

.PP
Redetermine who the owner is\&. If the owner has left, then a new owner should be chosen\&. 
.SS "void Group::run ()\fC [private]\fP"
This is function that will manage the \fBGroup\fP\&. 
.PP
\fBNote:\fP
.RS 4
This \fBMUST BE CALLED ASYNCHRONOUSLY\fP, because it will \fBBLOCK INDEFINITELY\fP 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBGROUP_ID\fP shaan97::sync::Group::gid\fC [private]\fP"

.PP
\fBGroup\fP ID for this \fC\fBGroup\fP\fP instance\&. 
.SS "std::unordered_map<\fBMemberName\fP, \fBMember\fP> shaan97::sync::Group::members\fC [private]\fP"
Mapping from \fBMember\fP names to \fBMember\fP
.PP
\fBNote:\fP
.RS 4
A map was chosen because it is easier to remember just the MemberName, so we can use it as a handle for a \fBMember\fP\&. 
.RE
.PP

.SS "\fBMemberName\fP shaan97::sync::Group::owner\fC [private]\fP"

.PP
Name of the current owner\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for Sync from the source code\&.
